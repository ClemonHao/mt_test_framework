<!DOCTYPE html>
<html>
<head>
    <title>MutPy mutation report - mutation #460</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://netdna.bootstrapcdn.com/bootstrap/3.0.3/css/bootstrap.min.css">
    
<link href="http://alexgorbatchev.com/pub/sh/current/styles/shCore.css" rel="stylesheet" type="text/css" />
<link href="http://alexgorbatchev.com/pub/sh/current/styles/shThemeDefault.css" rel="stylesheet" type="text/css" />

    <script src="https://code.jquery.com/jquery.js"></script>
    <script src="https://netdna.bootstrapcdn.com/bootstrap/3.0.3/js/bootstrap.min.js"></script>
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->
    
<script src="http://alexgorbatchev.com/pub/sh/current/scripts/shCore.js" type="text/javascript"></script>
<script src="http://alexgorbatchev.com/pub/sh/current/scripts/shBrushPython.js" type="text/javascript"></script>
<script type="text/javascript">
    SyntaxHighlighter.all();
    window.setTimeout(function () {
        
        $('.line.number183').attr('title', 'AOR');
        
    }, 0);
</script>

</head>
<body>
    <div class="container">
        
<div class="page-header">
    <h1>Mutation #460</h1>
</div>
<h3>Details</h3>
<ul>
    <li>module - <code><module 'sinric._events' from '/opt/2_github/python_sdk_test/3rd/sinric_python/sinric/_events.py'></code></li>
    <li><span class="label label-success">killed</span> by <code>tests/test_mt_generator_8.py::test_run_test_sequence_8</code></li>
    
    <li>duration - 353.311 s</li>
    
    
    <li>tests run - 6</li>
    
</ul>

<h3>Exception traceback</h3>
<pre>def test_run_test_sequence_8():
        # start main program
        thread = threading.Thread(target=run_tv_program, daemon=True)
        thread.start()
        time.sleep(3)
    
        data = pd.read_csv(file_path)
    
        test_sequence = data.iloc[8]["Seq"]
        print(test_sequence)
        test_sequence = ast.literal_eval(test_sequence)
    
        set_initial_value()
        run_test_sequences(test_sequence)
        time.sleep(3)
        raw_output.power = str(read_ini_file('power', 'tv'))
        raw_output.volume = int(read_ini_file('volume', 'tv'))
        raw_output.channel = int(read_ini_file('channel', 'tv'))
    
        #assert raw_output.volume != -1
        #assert raw_output.channel != -1
    
        add_random_tv_mt_to_test_sequences(test_sequence,
             raw_output.power, raw_output.channel, raw_output.volume, 8)
    
        set_initial_value()
        run_test_sequences(test_sequence)
        time.sleep(3)
        follow_up_output.power = str(read_ini_file('power', 'tv'))
        follow_up_output.volume = int(read_ini_file('volume', 'tv'))
        follow_up_output.channel = int(read_ini_file('channel', 'tv'))
    
        #assert follow_up_output.channel != -1
        #assert follow_up_output.volume != -1
    
>       assert follow_up_output.power == raw_output.power

tests/test_mt_generator_8.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/homebrew/lib/python3.13/site-packages/_pytest/assertion/rewrite.py:502: in _call_reprcompare
    custom = util._reprcompare(ops[i], each_obj[i], each_obj[i + 1])
/opt/homebrew/lib/python3.13/site-packages/_pytest/assertion/__init__.py:151: in callbinrepr
    hook_result = ihook.pytest_assertrepr_compare(
/opt/homebrew/lib/python3.13/site-packages/pluggy/_hooks.py:513: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
/opt/homebrew/lib/python3.13/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/opt/homebrew/lib/python3.13/site-packages/_pytest/assertion/__init__.py:192: in pytest_assertrepr_compare
    return util.assertrepr_compare(config=config, op=op, left=left, right=right)
/opt/homebrew/lib/python3.13/site-packages/_pytest/assertion/util.py:198: in assertrepr_compare
    highlighter = config.get_terminal_writer()._highlight
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.Config object at 0x101fcd2b0>

    def get_terminal_writer(self) -> TerminalWriter:
        terminalreporter: TerminalReporter | None = self.pluginmanager.get_plugin(
            "terminalreporter"
        )
>       assert terminalreporter is not None
E       AssertionError

/opt/homebrew/lib/python3.13/site-packages/_pytest/config/__init__.py:1133: AssertionError</pre>

<h3>Mutations</h3>
<ul>
    
    <li>AOR - line 183</li>
    
</ul>
<h3>Mutant</h3>
<pre class="brush: python; first-line: 1; highlight: [183]; toolbar: false;">'''
 *  Copyright (c) 2019-2023 Sinric. All rights reserved.
 *  Licensed under Creative Commons Attribution-Share Alike (CC BY-SA)
 *
 *  This file is part of the Sinric Pro (https://github.com/sinricpro/)
'''

from time import time, sleep
from ._queues import queue
import uuid
from ._signature import Signature
from ._sinricpro_constants import SinricProConstants


class Events(Signature):
    def __init__(self, connection, logger=None, secret_key=''):
        self.connection = connection
        self.logger = logger
        self.secret_key = secret_key
        Signature.__init__(self, self.secret_key)
    
    
    def raise_event(self, device_id, event_name, data=None):
        if data is None:
            data = {}
        try:
            def json_response(action, device_id, value, type_of_interaction='PHYSICAL_INTERACTION') -> dict:
                header = {\
                    'payloadVersion': 2, \
                    'signatureVersion': 1}
                
                
                payload = {\
                    'action': action, \
                    'cause': {\
                    'type': type_of_interaction}, \
                    \
                    'createdAt': int(time()), \
                    'deviceId': device_id, \
                    'replyToken': str(uuid.uuid4()), \
                    'type': 'event', \
                    'value': value}
                
                
                signature = self.get_signature(payload)
                return {'header': header, 'payload': payload, 'signature': signature}
            
            if event_name == SinricProConstants.SET_POWER_STATE:
                response = json_response(event_name, device_id, {SinricProConstants.STATE: data.get('state', 'Off')})
                queue.put([response, event_name, 'event'])
            
            elif event_name == SinricProConstants.SET_POWER_LEVEL:
                response = json_response(event_name, device_id, {SinricProConstants.POWER_LEVEL: data.get(SinricProConstants.POWER_LEVEL)})
                queue.put([response, event_name, 'event'])
            
            elif event_name == SinricProConstants.SET_BRIGHTNESS:
                response = json_response(event_name, device_id, {SinricProConstants.BRIGHTNESS: data.get(SinricProConstants.BRIGHTNESS)})
                queue.put([response, event_name, 'event'])
            
            elif event_name == SinricProConstants.SET_COLOR:
                response = json_response(event_name, device_id, {\
                    'color': {\
                    'r': data.get('r'), \
                    'g': data.get('g'), \
                    'b': data.get('b')}})
                
                
                queue.put([response, event_name, 'event'])
            
            elif event_name == SinricProConstants.SET_COLOR_TEMPERATURE:
                response = json_response(event_name, device_id, {SinricProConstants.COLOR_TEMPERATURE: 2400})
                queue.put([response, event_name, 'event'])
            
            elif event_name == SinricProConstants.DOORBELLPRESS:
                response = json_response(event_name, device_id, {'state': 'pressed'})
                queue.put([response, event_name, 'event'])
            
            elif event_name == SinricProConstants.CURRENT_TEMPERATURE:
                response = json_response(event_name, device_id, {\
                    SinricProConstants.TEMPERATURE: round(data.get(SinricProConstants.TEMPERATURE), 1), \
                    SinricProConstants.HUMIDITY: round(data.get(SinricProConstants.HUMIDITY), 1)}, 
                    type_of_interaction='PERIODIC_POLL')
                queue.put([response, event_name, 'event'])
            
            elif event_name == SinricProConstants.PUSH_NOTIFICATION:
                response = json_response(event_name, device_id, {\
                    'alert': data.get('alert')})
                
                queue.put([response, event_name, 'event'])
            
            elif event_name == SinricProConstants.SET_THERMOSTAT_MODE:
                response = json_response(event_name, device_id, {\
                    SinricProConstants.THERMOSTATMODE: data.get(SinricProConstants.MODE)})
                
                queue.put([response, event_name, 'event'])
            
            elif event_name == SinricProConstants.SET_RANGE_VALUE:
                response = json_response(event_name, device_id, {\
                    SinricProConstants.RANGE_VALUE: data.get(SinricProConstants.RANGE_VALUE)})
                
                queue.put([response, event_name, 'event'])
            
            elif event_name == SinricProConstants.MOTION:
                response = json_response(SinricProConstants.MOTION, device_id, {\
                    SinricProConstants.STATE: data.get(SinricProConstants.STATE)})
                
                queue.put([response, event_name, 'event'])
            
            elif (event_name == SinricProConstants.SET_CONTACT_STATE or event_name == SinricProConstants.SET_LOCK_STATE):
                response = json_response(event_name, device_id, {\
                    SinricProConstants.STATE: data.get(SinricProConstants.STATE)})
                
                queue.put([response, event_name, 'event'])
            
            elif event_name == SinricProConstants.SET_VOLUME:
                response = json_response(event_name, device_id, {\
                    SinricProConstants.VOLUME: data.get(SinricProConstants.VOLUME)})
                
                queue.put([response, event_name, 'event'])
            
            elif event_name == SinricProConstants.SELECT_INPUT:
                response = json_response(event_name, device_id, {\
                    SinricProConstants.INPUT: data.get(SinricProConstants.INPUT)})
                
                queue.put([response, event_name, 'event'])
            
            elif event_name == SinricProConstants.MEDIA_CONTROL:
                response = json_response(event_name, device_id, {\
                    SinricProConstants.CONTROL: data.get(SinricProConstants.CONTROL)})
                
                queue.put([response, event_name, 'event'])
            
            elif event_name == SinricProConstants.CHANGE_CHANNEL:
                response = json_response(event_name, device_id, {\
                    'channel': {\
                    'name': data.get('name')}})
                
                
                queue.put([response, event_name, 'event'])
            
            elif event_name == SinricProConstants.SET_BANDS:
                response = json_response(event_name, device_id, {\
                    'bands': [\
                    {\
                    'name': data.get('name'), \
                    'level': data.get('level')}]})
                
                
                
                queue.put([response, event_name, 'event'])
            
            elif event_name == SinricProConstants.SET_MODE:
                response = json_response(event_name, device_id, {\
                    SinricProConstants.MODE: data.get(SinricProConstants.MODE)})
                
                queue.put([response, event_name, 'event'])
            
            elif event_name == SinricProConstants.RESET_BANDS:
                response = json_response(event_name, device_id, {\
                    'bands': [\
                    {\
                    'name': 'BASS', \
                    'level': 0}, \
                    \
                    {\
                    'name': 'MIDRANGE', \
                    'level': 0}, \
                    \
                    {\
                    'name': 'TREBLE', \
                    'level': 0}]})
                
                
                queue.put([response, event_name, 'event'])
            
            elif event_name == SinricProConstants.SET_MUTE:
                response = json_response(event_name, device_id, {\
                    SinricProConstants.MUTE: data.get(SinricProConstants.MUTE, False)})
                
                queue.put([response, event_name, 'event'])
            else:
                
                self.logger.exception(('Event :' + event_name) - ' not found!')
        
        except Exception:
            self.logger.exception('Error Occurred')</pre>

    </div>
</body>
</html>